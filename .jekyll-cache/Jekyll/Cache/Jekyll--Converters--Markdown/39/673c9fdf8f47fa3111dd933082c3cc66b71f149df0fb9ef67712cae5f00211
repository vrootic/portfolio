I"G<p>Define functions is one of basic Python skills. I would like to focus on closure and its tricks.</p>

<h2 id="metadata">Metadata</h2>

<p>We can add some annotations on function in order to let programmers know how this function should be used.</p>

<noscript><pre>def add(x: int, y: int) -&gt; int:
    return x + y</pre></noscript>
<script src="https://gist.github.com/vrootic/7bfd08c3ee72b954a687c827ce8b2ba9.js"> </script>

<p>Python interpreter wouldnâ€™t give any semantic meaning on these statement. They are not type checks mechanism. However, they still give other maintainers enough clues to track code.</p>

<h2 id="if-functions-have-multiple-values-to-return-they-are-packed-in-tuple-and-returned">If functions have multiple values to return, they are packed in tuple and returned.</h2>

<h2 id="default-value-in-parameters">Default value in parameters</h2>

<noscript><pre>def spam(a, b=42):
    print(a, b)
    
spam(1)     # a=1, b=42
spam(1, 2)  # a=1, b=2


def spam(a, b=None):
    if b is None:
        b = []
    #...
    
_no_value = object()
def spam(a, b=_no_value):
    if b is _no_value:
        print(&#39;No b value supplied&#39;)
spam(1)     # No b value supplied
spam(1, 2)      # b=2
spam(1, None)   # b=None</pre></noscript>
<script src="https://gist.github.com/vrootic/07d976384d4310879c6967a1ee42c29f.js"> </script>

<p><strong>Indicated default values should always be immutable objects</strong>
Like None, True, False, number or string</p>

<h2 id="capture-variable-in-lambda">Capture variable in lambda</h2>

<noscript><pre>x = 10
a = lambda y: x + y
x = 20
b = lambda y: x + y

a(10)   # 30
b(10)   # 30

x = 15
a(10)   # 25
x = 3
a(10)   # 13

funcs = [lambda x: x+n for n in range(5)]
for f in funcs:
    print(f(0)) # 4, 4, 4, 4, 4
    
funcs = [lambda x, n=n: x+n for n in range(5)]
for f in funcs:
    print(f(0)) # 0, 1, 2, 3, 4</pre></noscript>
<script src="https://gist.github.com/vrootic/6b0c50430df61776627ec669d2ff5247.js"> </script>

<h2 id="using-functoolspartial">Using functools.partial</h2>

<noscript><pre># Suppose I have a list of points, I want to order this list by calculating distance for specific points.

from functools import partial
import math

points = [(1, 2), (3, 4), (5, 6), (7, 8)]
def distance(p1, p2):
    x1, x2 = p1
    y1, y2 = p2
    return math.hypot(x2 - x1, y2 - y1)

pt = (4, 3)
points.sort(key=partial(distance, pt))
points  # [(3, 4), (1, 2), (5, 6), (7, 8)]</pre></noscript>
<script src="https://gist.github.com/vrootic/c445cf3afffb1b74f4f65e8a88d6f5cc.js"> </script>

<h2 id="closure">Closure</h2>

<noscript><pre>def print_msg(msg):
    def printer():
        print(msg)    
    printer()
    
print_msg(&quot;hello&quot;)  # hello

def print_msg(msg):
    
    def printer():
        print(msg)
    
    return printer

f = print_msg(&quot;hello&quot;)
f()     # hello</pre></noscript>
<script src="https://gist.github.com/vrootic/6b33ec2f0f55eacd4dfe3e9c747ab288.js"> </script>

<h3 id="when-do-we-have-a-closure">When do we have a closure?</h3>

<ul>
  <li>We must have a nested function (function inside a function).</li>
  <li>The nested function must refer to a value defined in the enclosing function.</li>
  <li>The enclosing function must return the nested function.</li>
</ul>

<h3 id="when-to-use-closures">When to use closures?</h3>

<p>Closures can avoid the use of global values and provides some form of data hiding. It can also provide an object oriented solution to the problem.</p>

<p>We may want to replace single-method class with closure.</p>

<noscript><pre>from urllib.request import urlopen


# Original class 
class UrlTemplate:
    def __init__(self, template):
        self.template = template
    def open(self, **kwargs):
        return urlopen(self.template.format_map(kwargs))

# Closure method
def urltemplate(template):
    def opener(**kwargs):
        return urlopen(template.format_map(kwargs))
    return opener

</pre></noscript>
<script src="https://gist.github.com/vrootic/2b7aff3d95f782069f169c9a3f2bb200.js"> </script>

<p>We may also want our callback functions to bring additional information</p>

<noscript><pre>
def apply_async(func, args, *, callback):
    result = func(*args)
    
    callback(result)
    
def add(x, y):
    return x + y

# Using closure
def make_handler():
    sequence = 0
    def handler(result):
        nonlocal sequence
        sequence += 1
        print(&#39;[{}] Got: {}&#39;.format(sequence, result))
    return handler

handler = make_handler()
apply_async(add, (2, 3), callback=handler)  # [1] Got: 5
apply_async(add, (&#39;hello&#39;, &#39;world&#39;), callback=handler)  # [2] Got: helloworld</pre></noscript>
<script src="https://gist.github.com/vrootic/7d1e0902683bff9d05aa9bf5edd6aac1.js"> </script>

<h2 id="reference">Reference</h2>

<p>[1] <a href="https://www.programiz.com/python-programming/closure">Python Closures</a>
[2] Python cookbook 3rd version</p>
:ET